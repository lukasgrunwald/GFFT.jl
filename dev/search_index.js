var documenterSearchIndex = {"docs":
[{"location":"library/","page":"Library","title":"Library","text":"Full reference of implemented functions","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [GFFT]","category":"page"},{"location":"library/#GFFT.gfft_data","page":"Library","title":"GFFT.gfft_data","text":"gfft_data{FType, TI<:Integer, TF<:Real}\n\nContainer for gfft!-data that makes repeated application fast.\n\nFields\n\nmethod::Symbol: The method to use for the FFT (e.g., :fft or :ifft).\nsgn::TI: The sign used in the expression ĥ(y) = ∫ₐᵇ dx exp(sgn⋅ixy)h(x).\nN::TI: The length of the FFT-array (the full array is N+1).\nNh::TI: The index of the middle of the array (non-padded).\nNr::TI: The length of the array with padding.\nNrh::TI: The index of the middle of the array with padding.\nr::TI: The padding ratio.\na::TF: The lower boundary of the integral ∫ₐ.\nb::TF: The upper boundary of the integral ∫ᵇ.\ndx::TF: The discretization spacing of data to be transformed, calculated as (b - a) / N.\nx::Vector{Float64}: An array of data values, representing either time (t) or frequency (w).\nea::Vector{ComplexF64}: Corrective phase factors for the lower boundary.\neb::Vector{ComplexF64}: Corrective phase factors for the upper boundary.\nMfft::FType: The \"Matrix\" that applies the FFT or IFFT operation.\npad_container::Vector{ComplexF64}: A container for the padded array.\nW::Vector{Float64}: Attenuation factors used for Spline-FFT.\nA::Matrix{ComplexF64}: Boundary corrections for Spline-FFT.\n\n\n\n\n\n","category":"type"},{"location":"library/#GFFT.gfft_data-Tuple{Integer}","page":"Library","title":"GFFT.gfft_data","text":"gfft_data(sgn; N, r, a, b, method)\n\nConstructor for gfft_data struct, that contains FFT-data. sgn describes which transform is caluclated.\n\nNumerically calculate ĥ(y) = ∫ₐᵇ dx exp(sgn⋅ixy)h(x) for many values of y. The resulting argument-array y of a FFT is: \ninput ∈ [a, b] -> output = 2π/(r * (b-a)) * fftshift(-N*r/2, ..., N*r/2-1)\n\nArguments\n\nsgn::Integer: sgn = ±1 +1: fft [f(t) -> f̂(ω)] and -1: ifft [f̂(ω) -> f(t)]\nN::Integer: Length of initial-data to perform the FFT on (Array is N+1)\nr::Integer: Pading ratio (sinc(x) interpolation of the initial-data)\na, b::Float64: Lower and upper bound of x-array (No fftshift!)\nmethod{:spl3 (default), :trap, :riem}: Method used for the FFT\neps::Float64: Crossover value, at which we switch between the analytical expression and the Taylor expansion\nreturn: gfft_data struct\n\n\n\n\n\n","category":"method"},{"location":"library/#GFFT.FFTWeights-Tuple{Vector{<:AbstractFloat}, Real}","page":"Library","title":"GFFT.FFTWeights","text":"FFTWeights(x::Vector{<:AbstractFloat}, delta::Real; eps::Real=5.0e-2)\n\nGenerate W and A for the cubic spline-FFT. See numerical-recipies for definition of coeffs (http://numerical.recipes/book.html).\n\nArguments\n\neps::Float64 denotes the crossover value, at which we switch between the analytical expression   and the Taylor expansion (default experimentally found to optimze error)\nreturn: W, A where A[:, i] is the i-th boundary correction\n\n\n\n\n\n","category":"method"},{"location":"library/#GFFT.fftshift_odd!-Tuple{AbstractArray}","page":"Library","title":"GFFT.fftshift_odd!","text":"fftshift_odd!(x::AbstractArray)\n\nInplace FFT-shift of x (odd-array) which has index-structure [fftshift(-N/2:1:N/2-1); N/2].\n\nThese arrays apear e.g. when using the gfft for the iterative solution. This function still allocates, but modifies the underlying x.\n\n\n\n\n\n","category":"method"},{"location":"library/#GFFT.fftshift_odd-Tuple{AbstractArray}","page":"Library","title":"GFFT.fftshift_odd","text":"fftshift_odd(x::AbstractArray)\n\nCopy FFT-shift of x (odd-array) which has index-structure [fftshift(-N/2:1:N/2-1); N/2], i.e. while keeping the last index fixed.\n\n\n\n\n\n","category":"method"},{"location":"library/#GFFT.gfft!-Tuple{AbstractVector{ComplexF64}, AbstractVector{ComplexF64}}","page":"Library","title":"GFFT.gfft!","text":"gfft!(hy, hx; param::gfft_data, kwargs...)\ngfft!(sgn, hy, hx; a, b, r, kwargs...)\n\nNumerically calculate h(y) = ₐᵇ dx exp(sgnixy)h(x) for many values of y.\n\nResulting y(=t, ω) vectors will have the form x  a b - y = 2π(r * (b-a)) * (-N*r2  N*r2) (Assuming Isort=true). \nNote: Isort, Osort decides wether input/output are ordered or in the \"FFT-ordering\" (0, ..., x_{N/2-1}, x_{-N/2}, ..., x_{-1}, x_{N/2})`\n\nArguments\n\nIn iterative version (provides gfft_data) only:\n\nsgn::Int: sgn = ±1 in h(y) = ₐᵇ dx exp(sgnixy)h(x) (+1: fft (t->ω) and -1: ifft (ω->t))\nparam::gfft_data Struct generated with gfft_data\n\nIn standalone-version only:\n\nr: Pading ratio (sinc(x) interpolation of the data)\na, b: Lower and upper bound of w array (No fftshift!)\n\nGeneral:\n\nhx: h(x)-data (x=a+dx*j with j=0,...,N or FFT-ordering) (len=N+1)\nhy: ĥ(y) container\nIsort/Osort: If true, Input/Output in physical ordering. - boundary{:nearest (default), :spl3, :matsubara}: Decide method for extrapolation. :nearest approximates h(N/2)≈h(N/2-1) while :spl3 uses k=3 extrapolation. Matsubara   uses :spl3 for the final point (different because of ordering)\nmethod{:spl3, :trap, :riem}: Method to use for calculating FT\n\n(usually set when generating gfft_data).\n\nreturn: nothing\n\n\n\n\n\n","category":"method"},{"location":"library/#GFFT.gfft-Tuple{Integer, AbstractVector{ComplexF64}}","page":"Library","title":"GFFT.gfft","text":"gfft(sgn, hx; a, b, r=1, kwargs...)\n\nNumerically calculate h(y) = ₐᵇ dx exp(sgnixy)h(x) for many values of y. Allocates new array for hy-output. Returns Vector of FFT.\n\nResulting y(=t, ω) vectors will have the form x  a b - y = 2π(r * (b-a)) * (-N*r2  N*r2) (Assuming Isort=true). \nNote: Isort, Osort decides wether input/output are ordered or in the \"FFT-ordering\" (0, ..., x_{N/2-1}, x_{-N/2}, ..., x_{-1}, x_{N/2})`\n\nArguments\n\nIn iterative version (provides gfft_data) only:\n\nsgn::Int: sgn = ±1 in h(y) = ₐᵇ dx exp(sgnixy)h(x) (+1: fft (t->ω) and -1: ifft (ω->t))\nr: Pading ratio (sinc(x) interpolation of the data)\na, b: Lower and upper bound of w array (No fftshift!)\nhx: h(x)-data (x=a+dx*j with j=0,...,N or FFT-ordering) (len=N+1)\nIsort/Osort: If true, Input/Output in physical ordering. - boundary{:nearest (default), :spl3, :matsubara}: Decide method for extrapolation. :nearest approximates h(N/2)≈h(N/2-1) while :spl3 uses k=3 extrapolation. Matsubara   uses :spl3 for the final point (different because of ordering)\nmethod{:spl3, :trap, :riem}: Method to use for calculating FT\n\n(usually set when generating gfft_data).\n\nreturn: nothing\n\n\n\n\n\n","category":"method"},{"location":"library/#GFFT.gfftCorr!-Tuple{AbstractVector, AbstractVector, gfft_data, Bool, Symbol}","page":"Library","title":"GFFT.gfftCorr!","text":"gfftCorr!(sgn, hy, endpts, param, Isort, method)\n\nApply corrections to hy, for cubic-spline fft (:spl3) or trapezoidal-fft (:trap)correction. If Isort=true, one needs to multiply the data with ea.\n\nArguments\n\nendpts: Array of the endpoints in input array (len=8 for :spl2)\nmethod{:spl3(default), :trap, :riem}: Method endpoint corrections\nreturn: nothing\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = GFFT","category":"page"},{"location":"#GFFT","page":"Home","title":"GFFT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for GFFT, that numerically evaluates strongly oscillatory integrals of the form","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginequation\nhatf(y) = int_a^b rmdx e^pm i x cdot y f(x)\nendequation","category":"page"},{"location":"","page":"Home","title":"Home","text":"using an interpolation based approximation scheme. With an appropriate truncation, this can in particular be applied to Fourier transforms, both regular ones, and Matsubara versions. The focus of this module is on an implementation that yields a fast and accurate approximation to continuous Fourier transforms, using in place mutation and FFT-plans. ","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main functionality oft this library is implemented by the gfft! function, that evaluates (1) using an interpolation based approximation scheme, explained in the theory section. Next to the interpolation based scheme we provide other discretization schemes ","category":"page"},{"location":"","page":"Home","title":"Home","text":":riem: Riemann sum\n:trap: Trapezoidal rule\n:spl3: Spline-Interpolation scheme (third order), see Numerical recipies. This approach is in particular exact for polynomials up to 3rd-order. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A minimal working example, in which we numerically calculate the oscillatory integral hatf(omega) = int_-5^13 textdt  e^i omega t e^-t^2 sinh(3t), reads","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GFFT\n\nf(t) = exp(-t^2) * sinh(3 * t)\nN = 2^10 # Number of points (should be 2^x)\nr = 1 # Zero padding ratio (interpolation of frequency data)\na = -5 # lower bound of integral\nb = 13 # Upper bound of integral\n\n# Time array and associated frequency array (both normal ordering)\nt = a .+ collect(0:1:N) * (b - a) / N\nw = 2π / (r * (b - a)) * (-r*N/2:1:r*N/2) |> collect\nft = complex(f.(t)) # gfft expexts complex input array\n\n# Direct application\nfw = gfft(+1, ft; a, b, method = :spl3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Instead of directly calculating the Fourier transform, we can also preallocate the output array and generate FFTW plans, using the in-place interface","category":"page"},{"location":"","page":"Home","title":"Home","text":"# [...] (Definitions above)\nfw2 = Vector{ComplexF64}(undef, N + 1) # container for output\nOfft = gfft_data(+1; N=N, r = 1, a=a, b=b, method = :spl3) # gfft_data struct, containig FFT plan etc.\ngfft!(fw2, ft; param=Offt)\n\nfw2 == fw # true","category":"page"},{"location":"","page":"Home","title":"Home","text":"Further usage and options is explained in the docstrings and illustrated further in the benchmark and test.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Theoretical-Background","page":"Theory","title":"Theoretical Background","text":"","category":"section"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"This is part of an appendix of my master thesis in theoretical condensed matter physics, that explains the basic algorithm, and it's application to approximate continuous Fourier transforms. For an alternative and more complete description see the Fourier transform chapter of Numerical Recipies.","category":"page"},{"location":"tutorial/#The-DFT-Algorithm","page":"Theory","title":"The DFT Algorithm","text":"","category":"section"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"The DFT (and IDFT) maps a sequence sn mid n in  0 1 dots N-1  onto a new sequence hatsk mid k in 0 1 dots N-1  by implementing the sums","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginalign\n    text DFT quad hatsk = sum_n=0^N-1 e^-ifrac2piN n cdot k  sn \n    textIDFT quad sn = frac1Nsum_n=0^N-1 e^+ifrac2piN n cdot k  hatsk\nendalign","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"Because of the Euler identity e^2pi i k = 1  forall k in mathbbZ, a DFT always acts on the periodically continued signal, i.e. it is implied that hatsk+N=hatsk and in turn sn+N=sn, which can be seen by inspection of (1) and (2). The Euler identity also leads to the Nyquist theorem: The \"frequencies\" k in N2 dots N-1 are the same as k in -N2 dots -1, meaning that the DFT does not actually calculate frequencies with k geq N2, but rather, it always generates an (asymmetric) frequency-array around the origin, i.e. k in 0 dots N2-1 -N2 dots -1. An array in this ordering is called FFT-ordered. This array can be ordered in mathcalO(N) by using a circular index shift (circshift).","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"A naive implementation of the DFT has mathcalO(N^2) complexity, but with a clever trick which was popularized by the Cooley-Tukey FFT algorithm, this can be improved to mathcalO(N log(N)) if N = 2^m  m in mathbbN. (Generalizations are possible to the case where N is a product of low prime numbers, but these are extremely complicated.) The main insight comes from splitting of the DFT (or IDFT) into even and odd terms","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginalign\n    hatsk = sum_n=0^N2-1 e^-ifrac2piN2 n cdot k  s2n +\n    e^-ifrac2piNksum_n=0^N2-1 e^-ifrac2piN2 n cdot k  s2n+1 \n    = x_evenk + e^-ifrac2piNk x_oddk\nendalign","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"followed by the realization that x_odd and x_even are again DFT's with length N2 that can be calculated recursively. The recursion depth being x=log_2(N), hatsk can be calculated in mathcalObig( N^22^x + xN big) in mathcalO(N log(N)), where the first term describes the recursion and the second term the recombination step.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"Next to this basic idea, a plethora of tricks (cache locality, SIMD-instruction etc.) are used in modern DFT implementations leading to further mathcalO(N)-speedups. This is why in this thesis we use the Julia bindings to the FFTW (\"Fastest Fourier Transform in the West\") library for calculating DFT's, instead of relying on a custom version.","category":"page"},{"location":"tutorial/#Quadratures-for-Strongly-Oscillatory-Integrals","page":"Theory","title":"Quadratures for Strongly Oscillatory Integrals","text":"","category":"section"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"As a proxy for the continuous FT, we next discuss how to numerically calculate strongly oscillatory integrals for f: \\mathbb{R} \\to \\mathbb{C}, f \\in L^2 $ of the form","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginequation\n    hatf(omega) = int_a^b textd t   e^iomega t f(t)\nendequation","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"where we are usually interested in many values of omega. A naive, but illustrative approach is to choose a uniform discretization of the time axis t=a + jDelta jin0 N with spacing Delta = N^-1(b-a) and function values f_j equiv f(t_j), and to evaluate the integral using the trapezoidal-rule (or more generally Gregory Integration).[1]","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"The sum in the resulting expression","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginequation\n    hatf(omega) approx Delta e^iomega a sum_n=0^N-1 f_j e^iomega Delta j\n    - fracDelta2 Big( e^iomega ah_0 - e^iomega bh_N Big)\nendequation","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"can be efficiently calculated using the DFT, when choosing omega_j = 2pi (b-a)^-1  -fracN2 dots fracN2-1_j. As noted before, the frequency array resulting from a DFT is asymmetric around the origin, omega_-N2 being the smallest and omega_N2-1 the largest value. To generate a symmetric array, which is usually needed for further calculations, we obtain omega_N2 using a third-order spline extrapolation, using the last three frequency points. In cases where the data is \"noisy\", i.e. where we have residual fluctuations from the DFT we sometimes also use the previous frequency point as an approximation for omega_N2.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"Notice that the grid-spacing is delta omega sim (b-a)^-1 and omega_max sim N, meaning that while the latter is determined by our discretization, the first is fixed by the integral itself. It is possible to decrease delta omega by using zero-padding, but this only corresponds to a sinc-interpolation of the original hatf(omega) and thus does not contain new information, so that the frequency resolution in this approach is fundamentally limited by delta omega = 2pi (b-a)^-1. [2] Nonetheless, zero-padding is very useful, as it represents a cheap way to obtain a high order interpolation of hatf(omega) which is e.g. needed when hatf(omega) is to be used in further analysis.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"While (6) can give accurate results if lim_t to ab f(t) approx 0 fast enough (e.g. exponentially fast), in general it will be vastly inaccurate. The issue is that due to the oscillatory nature of the integral, the small parameter appearing in error terms is not Delta  (b-a), but rather omega Delta, which can become as large as pi. As a result (6) becomes systematically inaccurate as omega increases.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"A more sophisticated approach can be formulated by approximating f(t) by its polynomial interpolation of order s with mesh-points f_j equiv f(t_j), with t_j as defined above. This can be viewed as approximating f(t) by a sum of kernel functions which only depend on the interpolation scheme used","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginequation\n    f(t) approx\n     sum_j=0^N f_j psi bigg(fract-t_jDelta bigg) \n    + sum_j in textendpts f_j phi_j bigg(fract-t_jDeltabigg)\nendequation","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"Here psi(s) are the kernel function of an interior point (Lagrange-polynomials of order s) and phi_j(s) are the boundary corrections, which are needed since close to ab non-centered interpolation formulas have to be used. The number of endpoint functions is equal to 2s: s functions at every side of the interval. Inserting (7) into (5) and exchanging sum and integral, one can rewrite the expression as","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginequation\n    hatf(omega_n) = Delta e^iomega_n a W(theta_n) \n    sum_j=0^N-1 f_j e^itheta_n j\n    + Delta sum_k=0^s-1 Big( f_k alpha_k(theta_n) e^iomega_n a \n    + f_N-k tildealpha_k(theta_n) e^iomega_n b Big)\nendequation","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"Here we introduced the shorthand theta_n = omega_n Delta, with omega_n defined such that the DFT can be used for the first sum.[3] Further, we defined the two functions (the tildealpha_k's can be expressed in terms of alpha_k's, see below)","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginalign\n    W(theta) = int_-infty^infty textd s  e^istheta psi(s) qquad\n    alpha_j(theta) = int_-infty^infty textd s  e^itheta phi_j(s-j)\nendalign","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"For the cubic (s=3) interpolation scheme, the explicit expressions for W alpha tildealpha read","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginalign\n    W(theta) = left(frac6 + theta^23theta^4right)\n    left 3 - 4 costheta + cos 2 theta right \n    alpha_0(theta) = \n    frac(-42 + 5 theta^2) (6 theta^2) (8 cos theta - cos 2theta)6theta^4\n    + i frac(-12theta + 6theta^3) + (6 + theta^2) sin 2theta6theta^4 \n    alpha_1(theta) = frac14(3 - theta^2)- 7(6 + theta^2) cos theta6theta^4 + \n    frac30theta - 5(6 + theta^2) sin theta6theta^4 \n    alpha_2(theta) = frac-4(3 - theta^2) + 2(6 + theta^2) cos theta3theta^4 + \n    i frac-12theta + 2(6 + theta^2) sin theta3theta^4 \n    alpha_3(theta) = frac2(3 - theta^2) - (6 + theta^2) cos theta6 theta^4 +\n    i frac6theta - (6 + theta^2) sin theta6 theta^4 \n    tildealpha_0(theta) = frac(-6 + 11theta^2) + (6 theta^2)cos 2theta6theta^4 - i Imalpha_0(theta) \n    tildealpha_k geq 1(theta) = alpha_k^*(theta) \nendalign","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"These formulas have cancelations to high orders in theta, such that in a numerical implementation their 6th order Taylor-expansion has to be used for theta  011, instead of the full expression. The crossover-value of theta is determined experimentally as the value when Taylor expansion and analytical expression give the same result and dependents on details of the programming language and implementation (see benchmark/optimization_eps.jl). Note that the asymptotic complexity of (8) is the same as for the naive trapezoidal rule approach (6), i.e. mathcalO(N log N).","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"[1]: Since we want to evaluate the integral at many values of omega and because we often only know f(t) at fixed, evenly spaced points, standard high-order rules such as Gauss-quadratures are infeasible since they scale as mathcalO(N^2) and often even require interpolation. They would not be significantly more accurate than the trapezoidal rule anyway, as we will shortly explain.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"[2]: This is not an issue for us, since the values of ab will usually also be numerical parameters (see below).","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"[3]: Remarks concerning the omega-grid, made in the context of the naive approach, of course also apply here.","category":"page"},{"location":"tutorial/#Numerical-Fourier-Transforms","page":"Theory","title":"Numerical Fourier Transforms","text":"","category":"section"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"Calculating continuous FT's, which are integrals of type (5) with b=-a=infty, viz.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginalign\n    f(t) = int_-infty^infty fracdomega2 pi  e^-i omega t hatf(omega) qquad\n    hatf(omega) = int_-infty^infty dt  e^i omega t f(t)\nendalign","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"is in general very difficult. If the function falls off reasonably quickly at infinity (We found that a decay as mathcalO(t^-2omega^-2) is usually fast enough.), we can split the integration interval at some s_max and neglect the boundary terms sim int_s_max^infty dots, leaving us with an integral that can be performed using (8). The resulting frequency array has the form omega_j = fracpis_max -N2 dots N2_j, so that omega_max sim Ns_max and delta omega sim s_max^-1. Both parameters can be controlled by our discretization and cutoff. In general, the convergence in N s_max has to be checked on a case-by-case basis.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"If the function is not decaying fast enough, as is the case for the free retarted Greens function G^R(omega) stackrelomega to inftysim (omega + i0^+)^-1 equiv G_asy^R(omega) we can still use above formalism, given that the asymptotic behavior is known and that the FT of the asymptotic expression (here the FT of G_asy^R(omega)) can be worked out analytically. If this is the case, we numerically calculate the FT of (G^R - G^R_asy)(omega) and add the analytically obtained $ \\hat{G}^R_{asy.}(t)$ to the result","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginequation\n    G^R(t) approx int_-s_max^s_max fracdomega2 pi e^-i omega t \n    underbracebig(G^R - G_asy^Rbig)(omega)_in mathcalO(omega^-2)\n    + G_asy^R(t)\nendequation","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"In a numerical setting 0^+ in G_asy^R(omega) is replaced by a finite broadening factor 0^+ to eta=01, leading to the analytical result G_asy^R(t) = -iTheta(t) e^-eta t.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"In addition to continuous FT's appearing in the real time formalisms, we are also working in imaginary time, where the corresponding Matsubara Fourier Transforms (MFT) are defined as ","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginalign\n    f(tau) = frac1beta sum_omega_n e^-iomega_ntau hatf(iomega_n)  qquad\n    hatf(iomega_n) = int_0^beta dtau  e^iomega_ntau f(tau)\nendalign","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"with inverse temperature beta=frac1T and Matsubara frequencies omega_n = 2pi beta^-1 left( mathbbZ + zeta2 right)_n. We have zeta = 1 for fermions and zeta = 0 for bosons. Discretizing imaginary time as tau_j = Delta 0 dots N_j with Delta = beta  N, the transform f(tau) to hatf(i omega_n) can be calculated using (7) as","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginequation\n    hatf(iomega_n) =\n    int_0^beta dtau  e^i frac2pibeta n tau big e^zeta fracipibeta tau  f(tau) big\nendequation","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"where the additional phase factor appears because of the definition of Matsubara frequencies.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"The transform hatf(i omega_n) to f(tau) is again more tricky because of the infinite boundaries. If the function decays fast enough we can split the Matsubara sum at omega_max sim N_max and neglect the boundary term sim sum_N_max+1^infty dots, leaving us with a sum that can be calculated using the DFT, after an appropriate circshift. The resulting tau-array of the DFT has the form tildetau_j = fracbetaN-N2 dots N2_j, but because of the periodicity f(tau + beta) = (-1)^zeta f(tau), this is equivalent to tau in 0 beta. Explicitly, we thus implement","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"beginequation\n    f(tau_j) \n    approx frac1beta e^-zeta fracipibeta tau_j sum_ n leq N_max \n    e^-ifrac2pibeta n tau_j hatf(iomega_n)\nendequation","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"If the hatf(i omega) is not decaying fast enough, we again use the trick of subtracting and adding the asymptotic contribution. Such a slow decay is seen for G(i omega_n) stackreln to inftysim(i omega_n)^-1 equiv G_asy(i omega), where the analytically calculated transform of the asymptotic reads G_asy(tau) = -12 for tau in 0 beta.","category":"page"},{"location":"tutorial/","page":"Theory","title":"Theory","text":"In practice, we often successively apply FT's to the same set of functions in an iterative loop. In this case one can eliminate the need of doing a circshift after each iteration, if the integration interval is symmetric around the origin. In this case, applying the DFT to the ordered f-array followed by multiplication of e^iomega_n a [see (7)] is equivalent to just applying the DFT to the FFT-ordered array.","category":"page"}]
}
